"""
Extended visualization script for model predictions.
--------------------------------------------------

This module loads the ``model_predictions.csv`` file generated by the
``stress_predict_extended.ipynb`` notebook and produces both static
and interactive diagnostic plots.  In addition to the confusion matrix
and predicted-label distribution, it generates interactive HTML
visualisations using Plotly and a time–series scatter plot if a
``day`` column is present in the CSV.  These interactive charts can
be viewed directly in a browser and embedded in README files if
desired.

Usage::

    python visualize_output.py

Running the script will create several files in the working
directory:

* ``confusion_matrix.png`` – Static seaborn heatmap of the confusion matrix.
* ``predicted_distribution.png`` – Static bar chart of predicted labels.
* ``confusion_matrix_interactive.html`` – Interactive Plotly heatmap of the confusion matrix.
* ``predicted_distribution_interactive.html`` – Interactive Plotly histogram of predicted labels.
* ``time_series_predictions.html`` – Interactive scatter plot of predictions over time (if a ``day`` column exists).

The static charts will also display interactively if a graphical backend
is available.
"""

from __future__ import annotations

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import plotly.express as px
import sys


def main() -> None:
    """Entry point for the visualization script."""
    csv_path = 'model_predictions.csv'
    try:
        df = pd.read_csv(csv_path)
    except FileNotFoundError as exc:
        raise SystemExit(f"Could not find '{csv_path}'. Please run the model notebook first.") from exc

    # Determine the unique class names preserving natural order
    if 'actual_label' not in df.columns or 'predicted_label' not in df.columns:
        raise SystemExit("The CSV file must contain 'actual_label' and 'predicted_label' columns.")
    class_names = sorted(df['actual_label'].unique())

    # Compute confusion matrix
    cm = confusion_matrix(df['actual_label'], df['predicted_label'], labels=class_names)

    # --- Static confusion matrix using seaborn ---
    plt.figure(figsize=(8, 6))
    sns.heatmap(
        cm,
        annot=True,
        fmt='d',
        cmap='viridis',
        xticklabels=class_names,
        yticklabels=class_names
    )
    plt.xlabel('Predicted')
    plt.ylabel('Actual')
    plt.title('Confusion Matrix')
    plt.tight_layout()
    plt.savefig('confusion_matrix.png')
    try:
        plt.show()
    except Exception:
        pass
    plt.close()

    # --- Static distribution of predicted labels ---
    plt.figure(figsize=(8, 4))
    sns.countplot(
        data=df,
        x='predicted_label',
        order=class_names,
        color='skyblue'
    )
    plt.title('Distribution of Predicted Stress Levels')
    plt.xlabel('Predicted Label')
    plt.ylabel('Count')
    plt.tight_layout()
    plt.savefig('predicted_distribution.png')
    try:
        plt.show()
    except Exception:
        pass
    plt.close()

    # --- Interactive confusion matrix with Plotly ---
    fig_cm = px.imshow(
        cm,
        x=class_names,
        y=class_names,
        color_continuous_scale='Viridis',
        text_auto=True,
        labels=dict(x='Predicted', y='Actual', color='Count'),
        title='Confusion Matrix (Interactive)'
    )
    fig_cm.update_layout(height=500, width=600)
    fig_cm.write_html('confusion_matrix_interactive.html', include_plotlyjs='cdn')

    # --- Interactive distribution of predicted labels ---
    fig_hist = px.histogram(
        df,
        x='predicted_label',
        category_orders={'predicted_label': class_names},
        color='predicted_label',
        title='Distribution of Predicted Stress Levels (Interactive)',
        labels={'predicted_label': 'Predicted Label', 'count': 'Count'},
    )
    fig_hist.update_layout(showlegend=False)
    fig_hist.write_html('predicted_distribution_interactive.html', include_plotlyjs='cdn')

    # --- Time‑series scatter of predictions vs date (if available) ---
    if 'day' in df.columns:
        try:
            df['day'] = pd.to_datetime(df['day'])
            fig_time = px.scatter(
                df,
                x='day',
                y='predicted_label',
                color='actual_label',
                category_orders={'predicted_label': class_names, 'actual_label': class_names},
                labels={'day': 'Date', 'predicted_label': 'Predicted Label', 'actual_label': 'Actual Label'},
                title='Predicted vs Actual Stress Level Over Time'
            )
            fig_time.update_traces(marker=dict(size=6, opacity=0.7))
            fig_time.write_html('time_series_predictions.html', include_plotlyjs='cdn')
        except Exception:
            # If conversion fails, skip time-series plot
            print("Warning: 'day' column exists but could not be parsed as dates. Skipping time-series plot.", file=sys.stderr)


if __name__ == '__main__':
    main()